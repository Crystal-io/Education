# ER Modeling – Step-by-step Guide + Checklist (BA/SA тренажёр)

Цель: быстро и стабильно вытаскивать **сущности / таблицы / связи / ограничения** из текстового описания, доводя до “автоматизма”.

---

## Step-by-step гайд выявления сущностей и ER-модели

### Шаг 0. Зафиксировать цель и границы (Scope)
**Выход:** 1–2 предложения “что система делает” + что не делает (MVP).
- Что обязаны уметь хранить/показывать/считать?
- Где “истина” (system of record): у нас или во внешней системе?
- Что точно **out of scope** на 1й версии?

**Артефакт:** mini-scope + список out of scope.

---

### Шаг 1. Вытащить “существительные” и роли (Nouns & Actors)
Подчеркни в тексте:
- объекты: офис, заказ, счёт, бронь, товар, оборудование…
- роли/акторы: клиент, сотрудник, админ, ассистент…
- справочники/статусы: статус, тип, категория…

**Выход:** сырой список кандидатов (10–30 пунктов).

---

### Шаг 2. Классифицировать кандидатов: Entity vs Attribute vs Enum
Для каждого кандидата ответь на 3 вопроса:

1) Есть ли **жизненный цикл**? (создали/изменили/удалили/история)  
2) Будет ли **много экземпляров**? (много броней/заказов/платежей)  
3) Будут ли на него **ссылаться** другие? (FK, отчёты, фильтры)

Правило:
- **“да” ≥ 2** → скорее **Entity (таблица)**
- “это просто характеристика” → **Attribute (поле)**
- “ограниченный набор значений” → **Enum/Lookup (справочник)**

---

### Шаг 3. Разделить сущности на Reference vs Transaction
- **Reference/Master (справочники/мастера):** Employee, Office, Product, Equipment, Status
- **Transactional/Fact (факты/события):** Booking, Order, Payment, Shipment, AuditEvent

**Выход:** 2 списка (Reference / Transaction).

---

### Шаг 4. Найти связи через глаголы (verb → relation)
Ищи в тексте:
- “X имеет Y”, “X содержит Y”, “X делает Y”, “Y принадлежит X”

Определи кардинальность:
- 1–1 / 1–M / M–M

Правило M–M:
- если **и X и Y** могут повторяться многократно относительно друг друга → **таблица-связка**.

---

### Шаг 5. Определить “владение” и места FK (Parent/Child)
Вопросы:
- Что “родитель”, что “ребёнок”?
- Может ли “ребёнок” существовать без “родителя”?

Результат:
- FK у ребёнка (обычно)
- `NOT NULL` если без родителя существовать нельзя

---

### Шаг 6. Определить identity и ключи (PK/UK)
Для каждой Entity:
- **PK**: чаще surrogate `id` (bigserial/uuid)
- **Natural uniqueness (UK)**: если реально гарантируется бизнесом (code, external_id, composite)

Примеры композитных UK:
- `office_id + room_name`
- `merchant_id + external_order_id`

---

### Шаг 7. Проставить обязательность (NULL/NOT NULL)
Фильтр:
- обязательное для процесса → `NOT NULL`
- “иногда/может быть/опционально” → `NULL`
- “зависит от статуса” → nullable + правило/constraint/trigger позже

---

### Шаг 8. Вытянуть бизнес-правила → enforce в БД
Сначала выпиши правила словами, потом реши, чем обеспечивать:

- **FK** — целостность ссылок  
- **UNIQUE** — уникальность  
- **CHECK** — диапазоны/форматы/простая логика  
- **EXCLUDE (Postgres)** — запрет пересечений (время/диапазоны)  
- **TRIGGER** — если constraint не покрывает кейс

Примеры:
- `start_at < end_at` → CHECK  
- “нет пересечений” → EXCLUDE по `(resource_id, tsrange(...))`  
- “уникальный external_id в рамках merchant” → UNIQUE(merchant_id, external_id)

---

### Шаг 9. Нормализация: где 3NF, а где денорм допустима
Проверки:
- повторяющийся список значений → справочник / M–M
- вычисляемое поле → не хранить (или хранить snapshot при необходимости)
- “несколько значений в одном поле” (comma-separated) → почти всегда ошибка → делай связку

---

### Шаг 10. Прогон через “life queries” (жизненные запросы)
Сформулируй 5 типовых вопросов бизнеса и убедись, что модель легко отвечает:
- поиск/фильтры
- отчёты
- частые выборки
- ключевые проверки/валидации

Если запрос выглядит как ад — вероятно, сущности/связи выделены неверно.

---

## Чек-лист качества ER-модели (быстрая самопроверка)

### A) Сущности и атрибуты
- [ ] Для каждой сущности есть чёткая **граница ответственности**
- [ ] У каждой таблицы есть **PK**
- [ ] Нет “списков в одном поле” (`tags`, `equipment_list`) без причины
- [ ] Атрибуты не дублируют друг друга без необходимости (избегаем “копий истины”)

### B) Связи и кардинальности
- [ ] Все связи имеют явную кардинальность (1–1 / 1–M / M–M)
- [ ] M–M реализованы через **таблицу-связку**
- [ ] FK стоят у правильной стороны (child), отражают “владение”
- [ ] Nullable FK только там, где это реально допустимо

### C) Ключи, уникальность, целостность
- [ ] Проставлены нужные **UNIQUE** (natural keys / composite keys)
- [ ] Везде, где нужно, есть **FK** с понятной политикой `ON DELETE/UPDATE`
- [ ] Есть **CHECK** на базовую логику (например, start < end, amount >= 0)

### D) Статусы и справочники
- [ ] Статусы/типы не висят “произвольной строкой” (enum/lookup)
- [ ] Переходы статусов либо контролируются приложением, либо описаны правилами

### E) Временные данные и “пересечения”
- [ ] Временные поля выбраны осознанно (`timestamptz` vs `timestamp`)
- [ ] Нужные запреты пересечений/дубликатов обеспечены (UNIQUE/EXCLUDE/trigger)

### F) Запросы и бизнес-ценность
- [ ] Модель покрывает 5 “life queries” без костылей
- [ ] Модель не переусложнена для MVP (лишние сущности вынесены в later)

---

## Шаблон ответа на кейс (то, как мы будем сдавать решения)

1) **Nouns list** (кандидаты из текста)  
2) **Классификация** (Entity / Attribute / Enum)  
3) **Таблицы** (PK + ключевые поля)  
4) **Связи** (кардинальности, где FK, nullable?)  
5) **Ограничения / бизнес-правила** (3–6 пунктов)  
6) **Life queries** (5 вопросов, которые модель должна уметь)  
7) *(опционально)* **Out of scope (MVP)**

---

## Частые “запахи” ошибки (anti-patterns)
- [ ] `equipment_list`, `status_text`, `tags` как свободный текст → потеря нормализации/валидности
- [ ] M–M сделано через FK “в обе стороны” → нужна таблица-связка
- [ ] Нет способа запретить дубликаты/пересечения там, где бизнес требует
- [ ] Нет unique на external_id/кодах, которые “по бизнесу уникальны”
- [ ] Дублируем “истину” в нескольких таблицах без нужды (аномалии обновления)

---
